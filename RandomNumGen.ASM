.include "SysCalls.asm"
.data
	numPreSort:	.space 64
	numAfterSort:	.space 64
	completedNum:	.space 49
.text
.globl numGenStart
numGenStart:
	la $s0, numPreSort # loading registers with arrays for the remainder of RandomNumGen. $s0 holds array 1: numPreSort
	la $s1, numAfterSort # $s1 holds array 2: numAfterSort
	la $s2, completedNum # $s2 holds array 3: completedNum
	move $t0, $s0 # $t0 = #s0
	li $a1, 26 # $a1 = 26
	li $t1, 8 # $t1 = 8
loop1:
	li $t3, 0 # $t3 = 0
	li $v0, SysRandIntRange # service call: random int range
	syscall # run system call
	beq $a0, $zero, loop1 # if number generated = 0, generate new number
	beq $a0, 5, loop1 # if number generated = 5, generate new number
	beq $a0, 24, loop1 # if number generated = 24, generate new number
	beq $a0, 4, loop1 # if number generated = 4, generate new number
	rem $t4, $a0, 5 # $t4 = remainder of $a0 / 5
	bne $t4, 0, jump1 # jump if $t4 doesnt equal 0
	addi $t3, $t3, 1 # add one to #t3 if remainder equals 0
jump1:
	rem $t4, $a0, 4 # $t4 = remainder of $a0 / 4
	bne $t4, 0, jump2 # jump if $t4 doesnt equal 0
	addi $t3, $t3, 1 # add one to #t3 if remainder equals 0
jump2:
	bne $a0, 6, jump3 # jump if $a0 doesnt equal 6
	addi $t3, $t3, 1 # add one to #t3 if remainder equals 0
jump3:
	beq $t3, $zero, loop1 # if number generated didn't pass any of the previous 3 tests ( #t3 is equal to zero), generate new number
	sw $a0, ($t0) # if number passed test, put it into $t0
	addi $t0, $t0, 4 # $t0 += 4
	sw $a0, ($t0) # every number has to have a number it matches so put $a0 into $t0 again
	addi $t0, $t0, 4 # $t0 += 4
	addi $t1, $t1, -1 # t1 -= 1
	bne $zero, $t1, loop1 # if $t1 != 0, jump to Loop1	
	
	li $a1, 17 # $a1 = 17 ( 16 is largest number which can generated from SysRandIntRange)
	li $t2, 0 # $t2 = 0
loop2:
	li $v0, SysRandIntRange # service call: random int range
	syscall # run system call
	addi $a1, $a1, -1 # make largest number which can be generated by 1
	sll $a0, $a0, 2 # multiply number generated by 4 to get a byte address
	add $a0, $a0, $t2 # $a0 += $t2 (fill remaining unfilled array indexes)
	add $t0, $s0, $a0 # add array index to array memory location
	lw $t1, ($t0) # load value at that memory location in order to swap values to randomize
	add $t3, $s0, $t2 # $t3 = $s0 + $t2
	lw $t5, ($t3) # load value at other memory location in order to swap values to randomize
	sw $t5, ($t0) # store $t5 in $t0
	sw $t1, ($t3) # store $t1 in $t3
	add $t4, $s1, $t2 # $t4 = $s1 + $t2
	sw $t1, ($t4) # also place in array 3, $t4
	addi $t2, $t2, 4 # $t2 += 4
	bne $t2, 64 loop2 # loop if $t4 != 64
	
	li $t2, 16 # $t2 = 16
	li $a1, 2 # $a1 = 2
	li $s3, 46 # $s3 = 46 ascii value of a period
	move $t0, $s1 # $t0 = $s1
	move $t1, $s2 # $t1 = $s2
loop3:
	li $v0, SysRandIntRange # service call: random int range  generate a 0 or a 1
	syscall # run system call
	lw $t3, ($t0) # load $t3 in $t0
	beq $a0, 0, jump4 # if $a0 = 0 jump   $a0 = 1 means the number will be put into Num x Num format
	li $t5, 5 # $t5 = 5
	rem $t4, $t3, $t5 # $t4 = remainder $t3 / $t5
	beq $t4, $zero, jump5 # if $t4 = 0 jump
	li $t5, 4 # $t5 = 4
	rem $t4, $t3, 4 # $t4 = remainder $t3 / 4
	beq $t4, $zero, jump5 # if $t4 = 0 jump
	li $t5, 3 # $t5 = 3
jump5:
	li $v0, SysRandIntRange # service call: random int range  generate a 0 or a 1
	syscall # run system call
	div $t6, $t3, $t5 # $t6 = $t3 / $t5
	addi $t6, $t6, 48 # add 48 to $t6 to get an ascii value of num 1 of Num x Num
	addi $t5, $t5, 48 # add 48 to $t5 to get an ascii value of num 2 of Num x Num
	li $t7, 120 # $t7 = 120  ascii value of x
	beq $a0, 1, jump6 # if $a0 - 1 jump    This is to randomize whether or not to swap num 1 and num 2
	sb $t6, ($t1) # store byte $t6 into $t1
	sb $t7, 1($t1) # store byte $t7 into $t1
	sb $t5, 2($t1) # store byte $t5 into $t1
	addi $t1, $t1, 3 # add 3 to $t1
	j jump8 # jump to jump 8
jump6:
	sb $t5, ($t1) # store byte $t5 into $t1
	sb $t7, 1($t1) # store byte $t7 into $t1
	sb $t6, 2($t1) # store byte $t6 into $t1
	addi $t1, $t1, 3 # add 3 to $t1
	j jump8 # jump to jump 8
jump4: # this is if number will not be in Num x Num format
	blt $t3, 10 jump7 # if the number is less than 10, it doesn't need to be split up into two digits
	rem $t5, $t3, 10 # digit one equals #t3 modulus 10
	div $t3, $t3, 10 # digit 2 equals $t3 divided by 10
	addi $t3, $t3, 48 # $t3 += 48 to get an ascii value
	addi $t5, $t5, 48 #t5 += 48 to get an ascii value
	sb $t3, ($t1) # store $t3 into $t1
	sb $t5, 1($t1) # store $t5 into $t1
	sb $s3, 2($t1) # store $s3 into $t1 (period character)
	addi $t1, $t1, 3 # add 3 to $t1
	j jump8 # jump to jump 8
jump7:
	addi $t3, $t3, 48 # add 48 to $t3 to get an ascii value
	addi $t5, $t5, 48 # add 48 to $t5 to get and ascii value
	sb $t3, ($t1) # store $t3 into #t1
	sb $s3, 1($t1) # store #s3 into #t1 (period character)
	sb $s3, 2($t1) # store #s3 into #t1 (period character)
	addi $t1, $t1, 3 # add 3 to $t1
jump8:
	addi $t0, $t0, 4 # $t0 += 4
	addi $t2, $t2, -1 # $t2 -= 1
	bne $t2, $zero, loop3 # if $t2 doesnt equal zero, loop again
	sb $zero, ($t1) # store 0 in $t3
	
	jr $ra # jump to $ra
	
